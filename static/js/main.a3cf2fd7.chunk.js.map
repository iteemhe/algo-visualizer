{"version":3,"sources":["Algorithms/Dijkstra.js","AlgoVisualizer/Node/Node.jsx","AlgoVisualizer/AlgoVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["dijkstra","grid","startNode","finishNode","visitedNodes","distance","unvisitedNodes","nodes","row","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","isWall","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","col","filter","neighbor","getUnvisitedNeighbors","previousNode","Node","this","props","isFinish","isStart","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","Component","AlgoVisualizer","state","mouseIsPressed","initGrid","setState","updatedGrid","updateGrid","shortestPath","i","setTimeout","animateShortestPath","document","getElementById","nodesInShortestPathOrder","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","onClick","visualizeDijkstra","map","rowIndex","nodeIndex","mouseDown","mouseEnter","mouseUp","currRow","createNode","slice","updatedNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.a3cf2fd7.chunk.js","sourcesContent":["// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\n\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodes = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) {\n      continue;\n    }\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) {\n      return visitedNodes;\n    }\n    closestNode.isVisited = true;\n    visitedNodes.push(closestNode);\n    if (closestNode === finishNode) {\n      return visitedNodes;\n    }\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React, { Component } from \"react\";\n\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  render() {\n    const {\n      row,\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n    } = this.props;\n    const extraClassName = isFinish\n      ? \"node-finish\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : \"\";\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n      ></div>\n    );\n  }\n}\n","import React, { Component } from \"react\";\nimport { dijkstra, getNodesInShortestPathOrder } from \"../Algorithms/Dijkstra\";\nimport Node from \"./Node/Node\";\nimport \"./AlgoVisualizer.css\";\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\n\nexport default class AlgoVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n    };\n  }\n\n  /**\n   * Initialize the grid\n   */\n  componentDidMount() {\n    const grid = initGrid();\n    this.setState({ grid });\n  }\n\n  /**\n   * Detects and handles mouse down event\n   *\n   * @param {number} row\n   * @param {number} col\n   */\n  mouseDown(row, col) {\n    const updatedGrid = updateGrid(this.state.grid, row, col);\n    this.setState({ grid: updatedGrid, mouseIsPressed: true });\n  }\n\n  /**\n   * Detects and handles mouse enter event\n   *\n   * @param {number} row\n   * @param {number} col\n   * @returns\n   */\n  mouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) {\n      return;\n    }\n    const updatedGrid = updateGrid(this.state.grid, row, col);\n    this.setState({ grid: updatedGrid });\n  }\n\n  /**\n   * Detects and handle mouse up event\n   */\n  mouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  animateDijkstra(visitedNodes, shortestPath) {\n    for (let i = 0; i <= visitedNodes.length; i++) {\n      // Once we find the target node\n      if (i === visitedNodes.length) {\n        setTimeout(() => {\n          this.animateShortestPath(shortestPath);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodes[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, 10 * i);\n    }\n  }\n\n  /**\n   * Animates the shortest path from the algorithm\n   *\n   * @param {Array} shortestPath\n   */\n  animateShortestPath(shortestPath) {\n    for (let i = 0; i < shortestPath.length; i++) {\n      setTimeout(() => {\n        const node = shortestPath[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, 50 * i);\n    }\n  }\n\n  visualizeDijkstra() {\n    const { grid } = this.state;\n    // These two nodes are hard-coded for convenience\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    // Perform Dijkstra's Algorithm\n    const visitedNodes = dijkstra(grid, startNode, finishNode);\n    const shortestPath = getNodesInShortestPathOrder(finishNode);\n    this.animateDijkstra(visitedNodes, shortestPath);\n  }\n\n  render() {\n    const { grid, mouseIsPressed } = this.state;\n    return (\n      <>\n        <button onClick={() => this.visualizeDijkstra()}>\n          Visualize Dijkstra's Algorithm\n        </button>\n\n        <div className=\"grid\">\n          {grid.map((row, rowIndex) => {\n            // Create a new node with unique id\n            return (\n              <div key={rowIndex}>\n                {row.map((node, nodeIndex) => {\n                  const { row, col, isFinish, isStart, isWall } = node;\n                  return (\n                    <Node\n                      key={nodeIndex}\n                      row={row}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.mouseDown(row, col)}\n                      onMouseEnter={(row, col) => this.mouseEnter(row, col)}\n                      onMouseUp={() => this.mouseUp()}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </>\n    );\n  }\n}\n\n/**\n * Initialize the grid\n *\n * @returns an empty grid\n */\nconst initGrid = () => {\n  const grid = [];\n  // The row and col are hard-coded for convenience\n  for (let row = 0; row < 20; row++) {\n    const currRow = [];\n    for (let col = 0; col < 50; col++) {\n      currRow.push(createNode(col, row));\n    }\n    grid.push(currRow);\n  }\n  return grid;\n};\n\n/**\n * Node factory\n *\n * @param {number} col\n * @param {number} row\n * @returns\n */\nconst createNode = (col, row) => {\n  return {\n    row,\n    col,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\n/**\n * Update the gride after certain event\n *\n * @param {array} grid\n * @param {number} row\n * @param {number} col\n * @returns\n */\nconst updateGrid = (grid, row, col) => {\n  const updatedGrid = grid.slice();\n  const node = updatedGrid[row][col];\n  const updatedNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  updatedGrid[row][col] = updatedNode;\n  return updatedGrid;\n};\n","import \"./App.css\";\nimport AlgoVisualizer from \"./AlgoVisualizer/AlgoVisualizer\";\nimport \"./AlgoVisualizer/AlgoVisualizer.css\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <AlgoVisualizer></AlgoVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}